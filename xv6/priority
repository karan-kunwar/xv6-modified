vm.c:  cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
exec.c:  safestrcpy(proc->name, last, sizeof(proc->name));
exec.c:  oldpgdir = proc->pgdir;
exec.c:  proc->pgdir = pgdir;
exec.c:  proc->sz = sz;
exec.c:  proc->tf->eip = elf.entry;  // main
exec.c:  proc->tf->esp = sp;
console.c:      if(proc->killed){
fs.c:    ip = idup(proc->cwd);
proc.c:  sz = proc->sz;
proc.c:    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
proc.c:    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
proc.c:  proc->sz = sz;
proc.c:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
proc.c:  np->sz = proc->sz;
proc.c:  *np->tf = *proc->tf;
proc.c:    if(proc->ofile[i])
proc.c:      np->ofile[i] = filedup(proc->ofile[i]);
proc.c:  np->cwd = idup(proc->cwd);
proc.c:  safestrcpy(np->name, proc->name, sizeof(proc->name));
proc.c:    if(proc->ofile[fd]){
proc.c:      fileclose(proc->ofile[fd]);
proc.c:      proc->ofile[fd] = 0;
proc.c:  iput(proc->cwd);
proc.c:  proc->cwd = 0;
proc.c:  wakeup1(proc->parent);
proc.c:  proc->state = ZOMBIE;
proc.c:    if(!havekids || proc->killed){
proc.c:// and have changed proc->state. Saves and restores
proc.c:// be proc->intena and proc->ncli, but that would
proc.c:  if(proc->state == RUNNING)
proc.c:  swtch(&proc->context, cpu->scheduler);
proc.c:  proc->state = RUNNABLE;
proc.c:  proc->chan = chan;
proc.c:  proc->state = SLEEPING;
proc.c:  proc->chan = 0;
prc.c:  sz = proc->sz;
prc.c:    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
prc.c:    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
prc.c:  proc->sz = sz;
prc.c:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
prc.c:  np->sz = proc->sz;
prc.c:  *np->tf = *proc->tf;
prc.c:    if(proc->ofile[i])
prc.c:      np->ofile[i] = filedup(proc->ofile[i]);
prc.c:  np->cwd = idup(proc->cwd);
prc.c:  safestrcpy(np->name, proc->name, sizeof(proc->name));
prc.c:    if(proc->ofile[fd]){
prc.c:      fileclose(proc->ofile[fd]);
prc.c:      proc->ofile[fd] = 0;
prc.c:  iput(proc->cwd);
prc.c:  proc->cwd = 0;
prc.c:  wakeup1(proc->parent);
prc.c:  proc->state = ZOMBIE;
prc.c:    if(!havekids || proc->killed){
prc.c:// and have changed proc->state. Saves and restores
prc.c:// be proc->intena and proc->ncli, but that would
prc.c:  if(proc->state == RUNNING)
prc.c:  swtch(&proc->context, cpu->scheduler);
prc.c:  proc->state = RUNNABLE;
prc.c:  proc->chan = chan;
prc.c:  proc->state = SLEEPING;
prc.c:  proc->chan = 0;
pipe.c:      if(p->readopen == 0 || proc->killed){
pipe.c:    if(proc->killed){
mp.c:        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
sysproc.c:  return proc->pid;
sysproc.c:  addr = proc->sz;
sysproc.c:    if(proc->killed){
sysfile.c:  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
sysfile.c:    if(proc->ofile[fd] == 0){
sysfile.c:      proc->ofile[fd] = f;
sysfile.c:  proc->ofile[fd] = 0;
sysfile.c:  iput(proc->cwd);
sysfile.c:  proc->cwd = ip;
sysfile.c:      proc->ofile[fd0] = 0;
syscall.c:  if(addr >= proc->sz || addr+4 > proc->sz)
syscall.c:  if(addr >= proc->sz)
syscall.c:  ep = (char*)proc->sz;
syscall.c:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
syscall.c:  if((uint)i >= proc->sz || (uint)i+size > proc->sz)
syscall.c:  num = proc->tf->eax;
syscall.c:    proc->tf->eax = syscalls[num]();
syscall.c://  	cprintf("%s -> %d\n", syscallname[num], proc->tf->eax);
syscall.c:            proc->pid, proc->name, num);
syscall.c:    proc->tf->eax = -1;
sleeplock.c:  lk->pid = proc->pid;
trap.c:    if(proc->killed)
trap.c:    proc->tf = tf;
trap.c:    if(proc->killed)
trap.c:            proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
trap.c:    proc->killed = 1;
trap.c:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
trap.c:  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
trap.c:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
kernel.asm:      if(proc->killed){
kernel.asm:      if(proc->killed){
kernel.asm:  safestrcpy(proc->name, last, sizeof(proc->name));
kernel.asm:  oldpgdir = proc->pgdir;
kernel.asm:  proc->pgdir = pgdir;
kernel.asm:  oldpgdir = proc->pgdir;
kernel.asm:  proc->sz = sz;
kernel.asm:  proc->pgdir = pgdir;
kernel.asm:  proc->tf->eip = elf.entry;  // main
kernel.asm:  proc->tf->esp = sp;
kernel.asm:    ip = idup(proc->cwd);
kernel.asm:    ip = idup(proc->cwd);
kernel.asm:        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
kernel.asm:        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
kernel.asm:      if(p->readopen == 0 || proc->killed){
kernel.asm:      if(p->readopen == 0 || proc->killed){
kernel.asm:      if(p->readopen == 0 || proc->killed){
kernel.asm:    if(proc->killed){
kernel.asm:  sz = proc->sz;
kernel.asm:  sz = proc->sz;
kernel.asm:  proc->sz = sz;
kernel.asm:    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
kernel.asm:  proc->sz = sz;
kernel.asm:    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
kernel.asm:  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
kernel.asm:  np->sz = proc->sz;
kernel.asm:  *np->tf = *proc->tf;
kernel.asm:  np->sz = proc->sz;
kernel.asm:  *np->tf = *proc->tf;
kernel.asm:    if(proc->ofile[i])
kernel.asm:    if(proc->ofile[i])
kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
kernel.asm:  np->cwd = idup(proc->cwd);
kernel.asm:      np->ofile[i] = filedup(proc->ofile[i]);
kernel.asm:  np->cwd = idup(proc->cwd);
kernel.asm:  np->cwd = idup(proc->cwd);
kernel.asm:  safestrcpy(np->name, proc->name, sizeof(proc->name));
kernel.asm:  np->cwd = idup(proc->cwd);
kernel.asm:  safestrcpy(np->name, proc->name, sizeof(proc->name));
kernel.asm:  if(proc->state == RUNNING)
kernel.asm:  swtch(&proc->context, cpu->scheduler);
kernel.asm:  swtch(&proc->context, cpu->scheduler);
kernel.asm:    if(proc->ofile[fd]){
kernel.asm:      fileclose(proc->ofile[fd]);
kernel.asm:      proc->ofile[fd] = 0;
kernel.asm:  iput(proc->cwd);
kernel.asm:  proc->cwd = 0;
kernel.asm:  wakeup1(proc->parent);
kernel.asm:  wakeup1(proc->parent);
kernel.asm:  proc->state = ZOMBIE;
kernel.asm:    if(!havekids || proc->killed){
kernel.asm:  proc->chan = chan;
kernel.asm:  proc->state = SLEEPING;
kernel.asm:  proc->chan = 0;
kernel.asm:  proc->state = RUNNABLE;
kernel.asm:  proc->chan = chan;
kernel.asm:  proc->state = SLEEPING;
kernel.asm:  proc->chan = 0;
kernel.asm:  proc->chan = chan;
kernel.asm:  proc->state = SLEEPING;
kernel.asm:  proc->chan = 0;
kernel.asm:  lk->pid = proc->pid;
kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
kernel.asm:  if(addr >= proc->sz)
kernel.asm:  if(addr >= proc->sz)
kernel.asm:  ep = (char*)proc->sz;
kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
kernel.asm:  if((uint)i >= proc->sz || (uint)i+size > proc->sz)
kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
kernel.asm:  return fetchint(proc->tf->esp + 4 + 4*n, ip);
kernel.asm:  if(addr >= proc->sz || addr+4 > proc->sz)
kernel.asm:  if(addr >= proc->sz)
kernel.asm:  ep = (char*)proc->sz;
kernel.asm:  num = proc->tf->eax;
kernel.asm:    proc->tf->eax = syscalls[num]();
kernel.asm:            proc->pid, proc->name, num);
kernel.asm:    proc->tf->eax = -1;
kernel.asm:            proc->pid, proc->name, num);
kernel.asm:    proc->tf->eax = -1;
kernel.asm:  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
kernel.asm:    if(proc->ofile[fd] == 0){
kernel.asm:      proc->ofile[fd] = f;
kernel.asm:  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
kernel.asm:  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
kernel.asm:  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
kernel.asm:  proc->ofile[fd] = 0;
kernel.asm:  if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
kernel.asm:    if(proc->ofile[fd] == 0){
kernel.asm:    if(proc->ofile[fd] == 0){
kernel.asm:      proc->ofile[fd] = f;
kernel.asm:  iput(proc->cwd);
kernel.asm:  proc->cwd = ip;
kernel.asm:  proc->cwd = ip;
kernel.asm:    if(proc->ofile[fd] == 0){
kernel.asm:    if(proc->ofile[fd] == 0){
kernel.asm:      proc->ofile[fd0] = 0;
kernel.asm:      proc->ofile[fd] = f;
kernel.asm:      proc->ofile[fd] = f;
kernel.asm:    if(proc->ofile[fd] == 0){
kernel.asm:      proc->ofile[fd0] = 0;
kernel.asm:      proc->ofile[fd] = f;
kernel.asm:  return proc->pid;
kernel.asm:  addr = proc->sz;
kernel.asm:  addr = proc->sz;
kernel.asm:    if(proc->killed){
kernel.asm:    if(proc->killed){
kernel.asm:    if(proc->killed)
kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
kernel.asm:  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
kernel.asm:            proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
kernel.asm:            proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
kernel.asm:    proc->killed = 1;
kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
kernel.asm:  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
kernel.asm:    if(proc->killed)
kernel.asm:    proc->tf = tf;
kernel.asm:    if(proc->killed)
kernel.asm:    proc->tf = tf;
kernel.asm:  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
kernel.asm:  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
kernel.asm:  cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
kernel.asm:  cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
